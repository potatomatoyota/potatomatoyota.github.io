<!DOCTYPE html>
<html lang="zh-TW">
<head>
  
  
  <link rel="preload" as="image" href="img/default-cover.webp">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="img/Favicon.png" type="image/x-icon">
  <title>lastfm</title>
  <link href="style.css" rel="stylesheet" type="text/css" />
  <style>
    @keyframes likeAnimation {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      70% { transform: scale(0.9); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
   
    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
   
    .like-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 30px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      animation: likeAnimation 0.5s ease-out, fadeOut 0.5s ease-in 2s forwards;
    }
   
    .like-icon {
      font-size: 24px;
      color: #FF3366;
    }
   
    .like-text {
      font-size: 18px;
      font-weight: 500;
    }
  </style>

  
  <script type="module">
    import { getSaturatedDominantColor, getSafeTextColor } from './js/color-utils.js';
  
    window.getSaturatedDominantColor = getSaturatedDominantColor;
    window.getSafeTextColor = getSafeTextColor;
  </script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

</head>
<body>
  <div class="bg-transition" id="bgTransition"></div>
  <div class="container fade" id="app">
    <div class="album-wrapper">
      <img src="img/default-cover.webp" alt="default cover" class="album-cover">
      
    </div>
    <div class="track-info">
      <div class="track-name">è¼‰å…¥ä¸­...</div>
      <div class="album-name">è«‹ç¨å€™</div>
      <div class="artist-name">æ­£åœ¨è¼‰å…¥æ­Œæ›²è³‡è¨Š</div>
    </div>
  </div>
  
  
  <script>
    let currentTrackId = null;
    let currentAlbumImgUrl = null;
    let lastRenderTimestamp = 0;
    let isFirstLoad = true;
    let grayPixels = 0;
    let currentCardIndex = 0;
    let animationInProgress = false;
    let currentFontColor = '#ffffff';
    let touchStartY = 0;
    let revertTimeout = null;

    // é¦–å…ˆåœ¨ <head> æ¨™ç±¤å…§åŠ å…¥ CSS æ¨£å¼ (æ”¾åœ¨ç¾æœ‰ style.css é€£çµä¹‹å¾Œ)
    
    
    document.head.appendChild(styleElement);

    // æ›´æ–° loveTrack å‡½æ•¸
    async function loveTrack(track) {
      const apiKey = '058072f329723fb093f8e5610cd566cf';
      const apiSecret = 'e2f9cb0c1f902fa71d44bbe6769a9d53';
      const sessionKey = localStorage.getItem('lastfm_session_key');

      if (!sessionKey) {
        window.location.href ='https://www.last.fm/api/auth/?api_key=058072f329723fb093f8e5610cd566cf&cb=https://potatomatoyota.github.io/callback.html';
        return;
      }

      // ç¢ºèª track name å’Œ artist name å­˜åœ¨
      const trackName = track?.name?.trim();
      const artistName = track?.artist?.['#text']?.trim();

      if (!trackName || !artistName) {
        showNotification('æ­Œæ›²è³‡è¨Šä¸å®Œæ•´ï¼Œç„¡æ³•æŒ‰è®š', 'error');
        return;
      }

      // é¡¯ç¤ºè™•ç†ä¸­çš„é€šçŸ¥
      showNotification('è™•ç†ä¸­...', 'loading');

      // éœ€è¦å‚³é€çš„åƒæ•¸ï¼ˆæ³¨æ„é †åºï¼‰
      const params = {
        method: 'track.love',
        track: trackName,
        artist: artistName,
        api_key: apiKey,
        sk: sessionKey,
      };

      // å»ºç«‹ api_sigï¼ˆæ‰€æœ‰åƒæ•¸æŒ‰å­—æ¯æ’åºå¾Œæ¥ä¸Š secretï¼Œå†åš MD5ï¼‰
      const sortedKeys = Object.keys(params).sort();
      let sigBase = '';
      for (const key of sortedKeys) {
        sigBase += key + params[key];
      }
      sigBase += apiSecret;

      const api_sig = CryptoJS.MD5(sigBase).toString();

      // æ·»åŠ ç°½ç« èˆ‡æ ¼å¼
      params.api_sig = api_sig;
      params.format = 'json';

      // ä½¿ç”¨ URL encoded æ ¼å¼é€å‡º
      const formBody = new URLSearchParams(params).toString();

      try {
        const response = await fetch('https://ws.audioscrobbler.com/2.0/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: formBody
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('Last.fm å›å‚³éŒ¯èª¤:', errorText);
          showNotification('æŒ‰è®šå¤±æ•—', 'error');
          return;
        }

        const result = await response.json();
        console.log('æŒ‰è®šæˆåŠŸ:', result);
        showNotification('å·²æŒ‰è®šé€™é¦–æ­Œï¼', 'success');
      } catch (err) {
        console.error('ç¶²è·¯éŒ¯èª¤:', err);
        showNotification('æŒ‰è®šæ™‚ç™¼ç”ŸéŒ¯èª¤', 'error');
      }
    }

    // æ–°å¢é€šçŸ¥é¡¯ç¤ºå‡½æ•¸
    function showNotification(message, type = 'success') {
      // ç§»é™¤ä»»ä½•ç¾æœ‰çš„é€šçŸ¥
      const existingNotification = document.querySelector('.like-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // å‰µå»ºæ–°çš„é€šçŸ¥å…ƒç´ 
      const notification = document.createElement('div');
      notification.className = 'like-notification';
      
      // æ ¹æ“šé¡å‹è¨­å®šåœ–æ¨™
      let icon = '';
      switch (type) {
        case 'success':
          icon = 'â¤ï¸';
          break;
        case 'error':
          icon = 'âŒ';
          break;
        case 'loading':
          icon = 'â³';
          break;
        default:
          icon = 'ğŸ’¬';
      }
      
      notification.innerHTML = `
        <span class="like-icon">${icon}</span>
        <span class="like-text">${message}</span>
      `;
      
      // å°‡é€šçŸ¥æ·»åŠ åˆ°é é¢
      document.body.appendChild(notification);
      
      // è¨­å®šé€šçŸ¥é¡è‰²èˆ‡ç•¶å‰ç•Œé¢é…è‰²ä¸€è‡´
      if (currentFontColor) {
        notification.querySelector('.like-text').style.color = currentFontColor;
      }
      
      // è‡ªå‹•ç§»é™¤é€šçŸ¥
      setTimeout(() => {
        notification.remove();
      }, 2500);
    }



    const albumColorMap = {

      // æ ¼å¼: 'å°ˆè¼¯åç¨±-è—è¡“å®¶åç¨±': { background: 'rgba(r,g,b)', text: 'rgba(r,g,b)' }
      'ã‚¨ãƒ«ãƒ-ãƒ¨ãƒ«ã‚·ã‚«': { background: 'rgb(50, 70, 50)', text: 'rgb(168, 192, 168)' },
      
      // å¯ä»¥æŒ‰ç…§é€™å€‹æ ¼å¼æ·»åŠ æ›´å¤šå°ˆè¼¯
    };

    // åƒ…æ–‡å­—æ›´æ–°çš„å‹•ç•«
    async function renderTextOnly(track) {
      if (animationInProgress) return;
      animationInProgress = true;
      
      const albumImgUrl = track.image.find(img => img.size === "extralarge")['#text'];
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.src = albumImgUrl;

      img.onload = () => {
        // ç”Ÿæˆå”¯ä¸€çš„éµå€¼
        const albumKey = `${track.album['#text']}-${track.artist['#text']}`;
        
        // æª¢æŸ¥æ˜¯å¦æœ‰é è¨­çš„é¡è‰²
        let rawColor, textColor, bgColor, fontColor;
        
        if (albumColorMap[albumKey]) {
          // ä½¿ç”¨é è¨­é¡è‰²
          bgColor = albumColorMap[albumKey].background;
          fontColor = albumColorMap[albumKey].text;
          
          console.log(`ä½¿ç”¨é è¨­é¡è‰²æ–¹æ¡ˆ: ${albumKey}`);
        } else {
          // ä½¿ç”¨è‡ªå‹•è¨ˆç®—çš„é¡è‰²
          rawColor = getSaturatedDominantColor(img);
          textColor = getSafeTextColor(rawColor);
          bgColor = `rgb(${rawColor.r}, ${rawColor.g}, ${rawColor.b})`;
          fontColor = `rgb(${textColor.r}, ${textColor.g}, ${textColor.b})`;
        }

        transitionBackgroundColor(bgColor);
        document.body.style.color = fontColor;
        currentFontColor = fontColor;
        
        // æ›´æ–°æ‰€æœ‰æ–‡å­—é¡è‰²
        updateAllTextColors(fontColor);
      };
      
      const app = document.getElementById('app');
      const nameEl = app.querySelector('.track-name');
      const albumEl = app.querySelector('.album-name');
      const artistEl = app.querySelector('.artist-name');

      // æ·»åŠ æ–‡å­—é€€å‡ºå‹•ç•«
      nameEl.classList.add('text-slide-down');
      albumEl.classList.add('text-slide-down');
      artistEl.classList.add('text-slide-down');
      
      // ç­‰å¾…å‹•ç•«å®Œæˆ
      await new Promise(resolve => setTimeout(resolve, 400));
      
      // æ›´æ–°æ–‡å­—
      nameEl.textContent = track.name;
      albumEl.textContent = track.album['#text'];
      artistEl.textContent = track.artist['#text'];
      
      // ç§»é™¤é€€å‡ºå‹•ç•«ï¼Œæ·»åŠ é€²å…¥å‹•ç•«
      nameEl.classList.remove('text-slide-down');
      albumEl.classList.remove('text-slide-down');
      artistEl.classList.remove('text-slide-down');
      
      // å¼·åˆ¶é‡ç¹ª
      void nameEl.offsetWidth;
      void albumEl.offsetWidth;
      void artistEl.offsetWidth;
      
      nameEl.classList.add('text-slide-up');
      albumEl.classList.add('text-slide-up');
      artistEl.classList.add('text-slide-up');
      
      // è¨­ç½®æ–‡å­—é¡è‰²
      nameEl.style.color = currentFontColor;
      albumEl.style.color = currentFontColor;
      artistEl.style.color = currentFontColor;
      
      // ç§»é™¤é€²å…¥å‹•ç•«é¡åˆ¥
      setTimeout(() => {
        nameEl.classList.remove('text-slide-up');
        albumEl.classList.remove('text-slide-up');
        artistEl.classList.remove('text-slide-up');
        animationInProgress = false;
      }, 10);
    }
    
    // èƒŒæ™¯è‰²å¹³æ»‘éæ¸¡
    function transitionBackgroundColor(newColor) {
      const bgTransition = document.getElementById('bgTransition');
      bgTransition.style.backgroundColor = newColor;
      bgTransition.style.opacity = 1;
      
      setTimeout(() => {
        document.body.style.backgroundColor = newColor;
        bgTransition.style.opacity = 0;
      }, 500);
    }

    function updateAllTextColors(color) {
      const app = document.getElementById('app');
      
      // æ›´æ–°æ‰€æœ‰æ–‡å­—å…ƒç´ 
      const textElements = app.querySelectorAll('.track-name, .album-name, .artist-name');
      textElements.forEach(el => {
        el.style.color = color;
      });
      
      // æ›´æ–°æ‰€æœ‰é€£çµ
      const links = app.querySelectorAll('a');
      links.forEach(link => {
        link.style.color = color;
        link.style.textDecoration = 'none';
      });
    }

    async function renderFull(track) {
      if (animationInProgress) return;
      animationInProgress = true;
      
      const app = document.getElementById('app');
      const albumImgUrl = track.image.find(img => img.size === "extralarge")['#text'];
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.src = albumImgUrl;

      // å‰µå»ºLast.fmçš„URL
      const trackUrl = `https://www.last.fm/music/${encodeURIComponent(track.artist['#text'])}/_/${encodeURIComponent(track.name)}`;
      const albumUrl = `https://www.last.fm/music/${encodeURIComponent(track.artist['#text'])}/${encodeURIComponent(track.album['#text'])}`;
      const artistUrl = `https://www.last.fm/music/${encodeURIComponent(track.artist['#text'])}`;
      
      // ä½¿ç•¶å‰å°é¢åœ–ç‰‡é–‹å§‹é€€å ´å‹•ç•«
      const currentCover = app.querySelector('.album-cover');
      if (currentCover) {
        currentCover.classList.add('exit');
      }
      
      // ä½¿æ–‡å­—é–‹å§‹é€€å ´å‹•ç•«
      const trackInfo = app.querySelector('.track-info');
      if (trackInfo) {
        const textElements = trackInfo.querySelectorAll('div, a');
        textElements.forEach((el, i) => {
          el.classList.add('text-slide-down');
          el.style.transitionDelay = `${i * 50}ms`;
        });
      }

      // ä½¿ç”¨ Promise ä»£æ›¿ async/await
      return new Promise((resolveRender) => {
        img.onload = () => {
          // ç”Ÿæˆå”¯ä¸€çš„éµå€¼
          const albumKey = `${track.album['#text']}-${track.artist['#text']}`;
          
          // æª¢æŸ¥æ˜¯å¦æœ‰é è¨­çš„é¡è‰²
          let rawColor, textColor, bgColor, fontColor;
          
          if (albumColorMap[albumKey]) {
            // ä½¿ç”¨é è¨­é¡è‰²
            bgColor = albumColorMap[albumKey].background;
            fontColor = albumColorMap[albumKey].text;
            
            console.log(`ä½¿ç”¨é è¨­é¡è‰²æ–¹æ¡ˆ: ${albumKey}`);
          } else {
            // ä½¿ç”¨è‡ªå‹•è¨ˆç®—çš„é¡è‰²
            rawColor = getSaturatedDominantColor(img);
            textColor = getSafeTextColor(rawColor);
            bgColor = `rgb(${rawColor.r}, ${rawColor.g}, ${rawColor.b})`;
            fontColor = `rgb(${textColor.r}, ${textColor.g}, ${textColor.b})`;
          }
          
          transitionBackgroundColor(bgColor);
          document.body.style.color = fontColor;
          currentFontColor = fontColor;
          
          // ä½¿ç”¨ updateBackgroundFromImage è¿”å›çš„ Promise
          updateBackgroundFromImage(albumImgUrl)
            .then(() => {
              // ç­‰å¾…é€€å ´å‹•ç•«å®Œæˆ
              setTimeout(() => {
                // æº–å‚™æ–°çš„HTML
                const newHTML = `
                  <div class="album-wrapper">
                    <img src="${albumImgUrl}" alt="${track.album['#text']}" class="album-cover enter">
                    <div class="scroll-indicator" id="scrollIndicator"></div>
                  </div>
                  <div class="track-info">
                    <a href="${trackUrl}" target="_blank" class="track-name text-slide-up">${track.name}</a>
                    <a href="${albumUrl}" target="_blank" class="album-name text-slide-up">${track.album['#text']}</a>
                    <a href="${artistUrl}" target="_blank" class="artist-name text-slide-up">${track.artist['#text']}</a>
                  </div>
                `;

                app.innerHTML = newHTML;
                currentAlbumImgUrl = albumImgUrl;

                // æ›´æ–°æ‰€æœ‰æ–‡å­—é¡è‰²
                updateAllTextColors(fontColor);
                
                setTimeout(() => {
                  // å•Ÿå‹•å°é¢é€²å ´å‹•ç•«
                  const newCover = app.querySelector('.album-cover');
                  if (newCover) {
                    void newCover.offsetWidth; // å¼·åˆ¶é‡ç¹ª
                    newCover.classList.remove('enter');
                  }
                  
                  // å•Ÿå‹•æ–‡å­—é€²å ´å‹•ç•«
                  const textElements = app.querySelectorAll('.track-name, .album-name, .artist-name');
                  textElements.forEach((el, i) => {
                    el.style.transitionDelay = `${i * 100}ms`;
                    void el.offsetWidth; // å¼·åˆ¶é‡ç¹ª
                    el.classList.remove('text-slide-up');
                  });
                  
                  // é‡è¨­å‹•ç•«é€²è¡Œä¸­ç‹€æ…‹
                  setTimeout(() => {
                    animationInProgress = false;
                    resolveRender();
                  }, 800);
                }, 100);
              }, 600);
            });
        };
        
        // å¦‚æœåœ–ç‰‡åŠ è¼‰å¤±æ•—
        img.onerror = () => {
          console.error('Failed to load album image');
          animationInProgress = false;
          resolveRender();
        };
      });
    }

    function updateBackgroundFromImage(imageUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = imageUrl;

        img.onload = () => {
          // å¦‚æœæˆ‘å€‘æœ‰ç•¶å‰çš„æ›²ç›®è³‡è¨Šï¼Œæª¢æŸ¥æ˜¯å¦åœ¨é è¨­åˆ—è¡¨ä¸­
          if (window.currentTrackData) {
            const albumKey = `${window.currentTrackData.album['#text']}-${window.currentTrackData.artist['#text']}`;
            
            if (albumColorMap[albumKey]) {
              // ä½¿ç”¨é è¨­é¡è‰²
              const bgColor = albumColorMap[albumKey].background;
              const fontColor = albumColorMap[albumKey].text;
              
              transitionBackgroundColor(bgColor);
              document.body.style.color = fontColor;
              currentFontColor = fontColor;
              
              resolve();
              return;
            }
          }
          
          // å¦å‰‡ä½¿ç”¨è‡ªå‹•è¨ˆç®—çš„é¡è‰²
          const rawColor = getSaturatedDominantColor(img);
          const textColor = getSafeTextColor(rawColor);
          const bgColor = `rgb(${rawColor.r}, ${rawColor.g}, ${rawColor.b})`;
          const fontColor = `rgb(${textColor.r}, ${textColor.g}, ${textColor.b})`;

          transitionBackgroundColor(bgColor);
          document.body.style.color = fontColor;
          currentFontColor = fontColor;
          
          resolve();
        };

        img.onerror = () => {
          console.error('Failed to load image for background update:', imageUrl);
          reject();
        };
      });
    }

        
    async function renderApp(songData, isFirstLoad = false) {
      if (!songData?.track) return;

      const track = Array.isArray(songData.track) ? songData.track[0] : songData.track;

      const isNowPlaying = track['@attr']?.nowplaying === 'true';
      
      window.currentTrackData = track;
      
      // å¦‚æœä¸æ˜¯é¦–æ¬¡è¼‰å…¥ï¼Œåªåœ¨æ­£åœ¨æ’­æ”¾æ™‚æ›´æ–°
      if (!isNowPlaying && !isFirstLoad) return;

      const trackId = `${track.name}-${track.artist['#text']}`;
      const sameTrack = trackId === currentTrackId;

      const albumImgUrl = track.image.find(img => img.size === "extralarge")['#text'];

      if (sameTrack && !isFirstLoad) return;
      currentTrackId = trackId;

      if (albumImgUrl === currentAlbumImgUrl && !isFirstLoad) {
        renderTextOnly(track);
      } else {
        renderFull(track);
      }
    }
    async function getSongInfo() {
      try {
        const res = await fetch('https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=potatomatoyota&api_key=058072f329723fb093f8e5610cd566cf&format=json&limit=1'); 
        if (!res.ok) throw new Error('Fetch failed');
        const data = await res.json();
        
        const trackArray = data?.recenttracks?.track;
        if (Array.isArray(trackArray) && trackArray.length > 0) {
          return { track: trackArray[0] }; 
        } else {
          throw new Error('No track data available');
        }
      } catch (err) {
        console.error('å–å¾—æ­Œæ›²è³‡è¨Šæ™‚ç™¼ç”ŸéŒ¯èª¤:', err);
        const app = document.getElementById('app');
        app.innerHTML = `<div class="error-message">ç„¡æ³•ç²å–æ­Œæ›²è³‡è¨Šï¼Œè«‹ç¨å¾Œå†è©¦ã€‚</div>`; 
        return null;
      }
    }

   
    const shortcutCards = [
      { type: 'lastfm' },
      { type: 'link', title: 'YouTube', url: 'https://www.youtube.com', icon: 'img/Youtube.webp' },
      { type: 'link', title: 'bilibili', url: 'https://www.bilibili.com/', icon: 'img/bilibili.webp' },
      { type: 'link', title: 'reddit', url: 'https://www.reddit.com/', icon: 'img/reddit.webp' },
      { type: 'link', title: 'facebook', url: 'https://www.facebook.com/', icon: 'img/facebook.webp' },
      { type: 'link', title: 'GitHub', url: 'https://github.com', icon: 'img/github.webp' }
      ,
    ];


    
    
    function switchCard(index) {
      if (animationInProgress) return;

      let nextIndex = index;

    // å¾ªç’°è·³é lastfm å¡ç‰‡
      while (true) {
        if (nextIndex < 0) {
          nextIndex = shortcutCards.length - 1;
        } else if (nextIndex >= shortcutCards.length) {
          nextIndex = 0;
        }

        if (shortcutCards[nextIndex].type !== 'lastfm') {
          break;
        }

        nextIndex += index > currentCardIndex ? 1 : -1;
      }

      if (nextIndex === currentCardIndex) return;

      currentCardIndex = nextIndex;

      const card = shortcutCards[nextIndex];

      try {
        if (card.type === 'lastfm') {
          console.log('åˆ‡æ›åˆ°lastfmå¡ç‰‡ï¼Œç•¶å‰æ•¸æ“šç‹€æ…‹:', window.latestSongData);
          if (window.latestSongData) {
            
            const trackData = window.latestSongData.track || window.latestSongData;
           
           
            showLoadingState();
          
            getSongInfo().then(song => {
              if (song) {
                window.latestSongData = song;
                if (currentCardIndex === index) { 
                  const trackData = song.track || song;
                  
                }
              }
            });
          }
        } else if (card.type === 'link') {
        
          if (card.url && card.title && card.icon) {
            renderLinkCard(card);
          } else {
            console.error('ç„¡æ•ˆçš„éˆæ¥å¡ç‰‡æ•¸æ“š:', card);
            showErrorCard('å¡ç‰‡æ•¸æ“šä¸å®Œæ•´');
          }
        } else {
          console.error('æœªçŸ¥çš„å¡ç‰‡é¡å‹:', card.type);
          showErrorCard('æœªçŸ¥çš„å¡ç‰‡é¡å‹');
        }
      } catch (error) {
        console.error('å¡ç‰‡æ¸²æŸ“éŒ¯èª¤:', error);
        showErrorCard('å¡ç‰‡è¼‰å…¥å¤±æ•—');
        currentCardIndex = oldIndex; 
      }
    }

  
  function showLoadingState() {
    const app = document.getElementById('app');
    
    const html = `
      <div class="album-wrapper">
        <img src="img/default-cover.webp" alt="è¼‰å…¥ä¸­" class="album-cover">
      </div>
      <div class="track-info">
        <div class="track-name">è¼‰å…¥ä¸­...</div>
        <div class="album-name">è«‹ç¨å€™</div>
        <div class="artist-name">æ­£åœ¨è¼‰å…¥è³‡è¨Š</div>
      </div>
    `;
    
    app.innerHTML = html;
    animationInProgress = false;
  }

  // éŒ¯èª¤å¡ç‰‡é¡¯ç¤º
  function showErrorCard(message = 'è¼‰å…¥å¤±æ•—') {
    const app = document.getElementById('app');
    
    const html = `
      <div class="album-wrapper">
        <div class="error-icon">âŒ</div>
      </div>
      <div class="track-info">
        <div class="track-name">${message}</div>
        <div class="album-name">ç™¼ç”ŸéŒ¯èª¤</div>
        <div class="artist-name">è«‹å˜—è©¦é‡æ–°è¼‰å…¥é é¢</div>
      </div>
    `;
    
    app.innerHTML = html;
    animationInProgress = false;
  }

  
  function renderLinkCard(card) {
    if (!card || !card.url || !card.title || !card.icon) {
      console.error('ç„¡æ•ˆçš„å¡ç‰‡æ•¸æ“š:', card);
      showErrorCard('å¡ç‰‡æ•¸æ“šä¸å®Œæ•´');
      return;
    }

    animationInProgress = true;
    const app = document.getElementById('app');

    const html = `
      <div class="album-wrapper link-card">
        <a href="${card.url}" target="_blank">
          <img src="${card.icon}" alt="${card.title}" class="album-cover" />
        </a>
      </div>
      <div class="track-info">
        <a href="${card.url}" target="_blank" class="track-name">${card.title}</a>
        <div class="album-name">ç¶²ç«™æ·å¾‘</div>
        <div class="artist-name">${card.url}</div>
      </div>
    `;

    app.innerHTML = html;

    document.body.style.color = currentFontColor;
    updateAllTextColors(currentFontColor);

    animationInProgress = false;

    const cover = app.querySelector('.album-cover');

    if (cover) {
      cover.addEventListener('mouseleave', () => {
        if (revertTimeout) clearTimeout(revertTimeout);
        revertTimeout = setTimeout(() => {
          
          currentCardIndex = 0; 
          
          
          if (window.latestSongData?.track) {
            renderFull(window.latestSongData.track);
            getSongInfo().then(song => {
              if (song?.track) {
                window.latestSongData = song;
                if (currentCardIndex === 0) { 
                  renderApp(song);
                }
              }
            });
          } else {
            getSongInfo().then(song => {
              if (song?.track) {
                window.latestSongData = song;
                if (currentCardIndex === 0) {
                  renderFull(song.track);
                }
              } else {
                showErrorCard('ç„¡æ³•è¼‰å…¥æ­Œæ›²');
              }
            });
          }

        }, 3000); // 3ç§’å¾Œè‡ªå‹•åˆ‡æ›å› lastfm
      });

      cover.addEventListener('mouseenter', () => {
        if (revertTimeout) {
          clearTimeout(revertTimeout); // å¦‚æœæ»‘é¼ åˆç§»å…¥ï¼Œå°±å–æ¶ˆåˆ‡æ›
          revertTimeout = null;
        }
      });
    }
  }
      
      function handleWheel(event) {
        if (animationInProgress) return;
        const direction = event.deltaY > 0 ? 1 : -1;
        switchCard(currentCardIndex + direction);
      }

      function handleTouchStart(e) { 
        touchStartY = e.touches[0].clientY; 
      }

      function handleTouchEnd(e) {
        const diffY = e.changedTouches[0].clientY - touchStartY;
        if (Math.abs(diffY) < 50 || animationInProgress) return;
        const direction = diffY < 0 ? 1 : -1;
        switchCard(currentCardIndex + direction);
      }

    

      
      function preloadShortcutImages() {
        shortcutCards.forEach(card => {
          if (card.type === 'link' && card.icon) {
            const img = new Image();
            img.src = card.icon;
            console.log(`é åŠ è¼‰åœ–ç‰‡: ${card.icon}`);
          }
        });
      }

  document.addEventListener('DOMContentLoaded', async () => {
    // é åŠ è¼‰æ‰€æœ‰æ·å¾‘åœ–ç‰‡
    preloadShortcutImages();
    
    // é¦–æ¬¡è¼‰å…¥å¼·åˆ¶è¼‰å…¥
    const firstCard = shortcutCards[0];
    currentCardIndex = 0;

    if (firstCard.type === 'lastfm') {
      const song = await getSongInfo();
      if (song?.track) {
        renderApp(song, true);
      } else if (song) {
        renderApp({ track: song }, true);
      }
    } else {
      renderLinkCard(firstCard);
    }

    document.addEventListener('wheel', handleWheel);
    document.addEventListener('touchstart', handleTouchStart);
    document.addEventListener('touchend', handleTouchEnd);
    
    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space' && !event.repeat && shortcutCards[currentCardIndex].type === 'lastfm') {
        event.preventDefault();
        if (window.currentTrackData) {
          loveTrack(window.currentTrackData);
        }
      }
    });

    // å®šæ™‚æ›´æ–°
    setInterval(async () => {
      const song = await getSongInfo();
      if (song) {
        // ä¿å­˜æœ€æ–°æ•¸æ“šä½†åªåœ¨é¡¯ç¤º last.fm å¡ç‰‡æ™‚æ‰æ¸²æŸ“
        window.latestSongData = song;
        if (shortcutCards[currentCardIndex].type === 'lastfm') {
          renderApp(song, false);
        }
      }
    }, 10000);
  });
  </script>
</body>
</html>